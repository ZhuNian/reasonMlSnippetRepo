// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var ExpressionEvaluator$ExpressionParser = require("./expressionEvaluator.js");

function run(p, input) {
  return Curry._1(p, input);
}

function pChar(match_, input) {
  var $$char = input.charAt(0);
  if (Curry._1(match_, $$char)) {
    var remaining = input.slice(1, input.length);
    var result = /* tuple */[
      $$char,
      remaining
    ];
    return /* Ok */Block.__(0, [result]);
  } else {
    return /* Error */Block.__(1, ["pchar error"]);
  }
}

function $pipe$at$(r, fn) {
  if (r.tag) {
    return /* Error */Block.__(1, [r[0]]);
  } else {
    return Curry._1(fn, r[0]);
  }
}

function $pipe$at$caret(r, fn) {
  if (r.tag) {
    return Curry._1(fn, r[0]);
  } else {
    return /* Ok */Block.__(0, [r[0]]);
  }
}

function $unknown$great(p1, p2, input) {
  return $pipe$at$(Curry._1(p1, input), (function (param) {
                var v1 = param[0];
                return $pipe$at$(Curry._1(p2, param[1]), (function (param) {
                              var res_000 = /* tuple */[
                                v1,
                                param[0]
                              ];
                              var res_001 = param[1];
                              var res = /* tuple */[
                                res_000,
                                res_001
                              ];
                              return /* Ok */Block.__(0, [res]);
                            }));
              }));
}

function $unknown$pipe(p1, p2, input) {
  return $pipe$at$caret(Curry._1(p1, input), (function () {
                return $pipe$at$(Curry._1(p2, input), (function (param) {
                              return /* Ok */Block.__(0, [/* tuple */[
                                          param[0],
                                          param[1]
                                        ]]);
                            }));
              }));
}

var isChar = Caml_obj.caml_equal;

function isNumberChar(input) {
  return (/\d/).test(input);
}

function many(p, input) {
  return $pipe$at$(Curry._1(p, input), (function (param) {
                var remaining = param[1];
                var v1 = param[0];
                var match = many(p, remaining);
                if (match.tag) {
                  return /* Ok */Block.__(0, [/* tuple */[
                              /* array */[v1],
                              remaining
                            ]]);
                } else {
                  var match$1 = match[0];
                  var v2 = match$1[0];
                  v2.unshift(v1);
                  var res_001 = match$1[1];
                  var res = /* tuple */[
                    v2,
                    res_001
                  ];
                  return /* Ok */Block.__(0, [res]);
                }
              }));
}

function $great$great$eq(p, func, input) {
  return $pipe$at$(Curry._1(p, input), (function (param) {
                return /* Ok */Block.__(0, [/* tuple */[
                            Curry._1(func, param[0]),
                            param[1]
                          ]]);
              }));
}

function empty(s) {
  if (s.length === 0) {
    return /* Ok */Block.__(0, [/* tuple */[
                s,
                ""
              ]]);
  } else {
    return /* Error */Block.__(1, ["parse empty error"]);
  }
}

function parser_(input) {
  var numberParser = function (param) {
    return $great$great$eq((function (param) {
                  return many((function (param) {
                                return pChar(isNumberChar, param);
                              }), param);
                }), (function (res) {
                  return /* Number */Block.__(0, [Caml_format.caml_float_of_string(res.join())]);
                }), param);
  };
  var parenParser = function (param) {
    return $great$great$eq((function (param) {
                  return $unknown$great((function (param) {
                                return $unknown$great((function (param) {
                                              return pChar((function (param) {
                                                            return Caml_obj.caml_equal("(", param);
                                                          }), param);
                                            }), parser_, param);
                              }), (function (param) {
                                return pChar((function (param) {
                                              return Caml_obj.caml_equal(")", param);
                                            }), param);
                              }), param);
                }), (function (param) {
                  return /* Paren */Block.__(3, [param[0][1]]);
                }), param);
  };
  var valueParser = function (param) {
    return $unknown$pipe(numberParser, parenParser, param);
  };
  var opParser = function (param) {
    return $great$great$eq((function (param) {
                  return pChar((function (c) {
                                if (c === "+") {
                                  return true;
                                } else {
                                  return c === "-";
                                }
                              }), param);
                }), (function (c, n1, n2) {
                  var match = c === "+";
                  if (match) {
                    return /* Add */Block.__(1, [
                              n1,
                              n2
                            ]);
                  } else {
                    return /* Minus */Block.__(2, [
                              n1,
                              n2
                            ]);
                  }
                }), param);
  };
  var addParser = function (param) {
    return $great$great$eq((function (param) {
                  return $unknown$great(valueParser, (function (param) {
                                return many((function (param) {
                                              return $unknown$great(opParser, valueParser, param);
                                            }), param);
                              }), param);
                }), (function (param) {
                  return param[1].reduce((function (res, param) {
                                return Curry._2(param[0], res, param[1]);
                              }), param[0]);
                }), param);
  };
  return $unknown$pipe(addParser, valueParser, input);
}

function parser(param) {
  return $great$great$eq((function (param) {
                return $unknown$great(parser_, empty, param);
              }), (function (param) {
                return param[0];
              }), param);
}

var exp = "1+2+(5-4)";

var match = parser(exp);

if (match.tag) {
  console.log(match[0]);
} else {
  console.log(ExpressionEvaluator$ExpressionParser.$$eval(match[0][0]));
}

exports.run = run;
exports.pChar = pChar;
exports.$pipe$at$ = $pipe$at$;
exports.$pipe$at$caret = $pipe$at$caret;
exports.$unknown$great = $unknown$great;
exports.$unknown$pipe = $unknown$pipe;
exports.isChar = isChar;
exports.isNumberChar = isNumberChar;
exports.many = many;
exports.$great$great$eq = $great$great$eq;
exports.empty = empty;
exports.parser_ = parser_;
exports.parser = parser;
exports.exp = exp;
/* match Not a pure module */
