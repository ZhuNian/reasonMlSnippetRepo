// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var ExpressionEvaluator$ExpressionParser = require("./expressionEvaluator.js");

var ParseError = Caml_exceptions.create("Parser-ExpressionParser.ParseError");

function run(p, input) {
  return Curry._1(p, input);
}

function pChar(match_, input) {
  var $$char = input.charAt(0);
  if (Curry._1(match_, $$char)) {
    var remaining = input.slice(1, input.length);
    var result = /* tuple */[
      $$char,
      remaining
    ];
    return /* Ok */Block.__(0, [result]);
  } else {
    return /* Error */Block.__(1, ["pchar error"]);
  }
}

function $pipe$at$(r, fn) {
  if (r.tag) {
    return /* Error */Block.__(1, [r[0]]);
  } else {
    return Curry._1(fn, r[0]);
  }
}

function $pipe$at$caret(r, fn) {
  if (r.tag) {
    return Curry._1(fn, r[0]);
  } else {
    return /* Ok */Block.__(0, [r[0]]);
  }
}

function $unknown$great(p1, p2, input) {
  return $pipe$at$(Curry._1(p1, input), (function (param) {
                var v1 = param[0];
                return $pipe$at$(Curry._1(p2, param[1]), (function (param) {
                              var res_000 = /* tuple */[
                                v1,
                                param[0]
                              ];
                              var res_001 = param[1];
                              var res = /* tuple */[
                                res_000,
                                res_001
                              ];
                              return /* Ok */Block.__(0, [res]);
                            }));
              }));
}

function $unknown$pipe(p1, p2, input) {
  return $pipe$at$caret(Curry._1(p1, input), (function (param) {
                return $pipe$at$(Curry._1(p2, input), (function (param) {
                              return /* Ok */Block.__(0, [/* tuple */[
                                          param[0],
                                          param[1]
                                        ]]);
                            }));
              }));
}

function $great$great$eq(p, func, input) {
  return $pipe$at$(Curry._1(p, input), (function (param) {
                try {
                  return /* Ok */Block.__(0, [/* tuple */[
                              Curry._1(func, param[0]),
                              param[1]
                            ]]);
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === ParseError) {
                    return /* Error */Block.__(1, [exn[1]]);
                  } else {
                    throw exn;
                  }
                }
              }));
}

var isChar = Caml_obj.caml_equal;

function isNumberChar(input) {
  return (/\d/).test(input);
}

function many(p, input) {
  return $pipe$at$(Curry._1(p, input), (function (param) {
                var remaining = param[1];
                var v1 = param[0];
                var match = many(p, remaining);
                if (match.tag) {
                  return /* Ok */Block.__(0, [/* tuple */[
                              /* array */[v1],
                              remaining
                            ]]);
                } else {
                  var match$1 = match[0];
                  var v2 = match$1[0];
                  v2.unshift(v1);
                  var res_001 = match$1[1];
                  var res = /* tuple */[
                    v2,
                    res_001
                  ];
                  return /* Ok */Block.__(0, [res]);
                }
              }));
}

function empty(s) {
  if (s.length === 0) {
    return /* Ok */Block.__(0, [/* tuple */[
                s,
                ""
              ]]);
  } else {
    return /* Error */Block.__(1, [s]);
  }
}

function numberParser(param) {
  return $great$great$eq((function (param) {
                return many((function (param) {
                              return pChar(isNumberChar, param);
                            }), param);
              }), (function (res) {
                return /* Number */Block.__(0, [Caml_format.caml_float_of_string(res.join(""))]);
              }), param);
}

function parenParser(p) {
  return (function (param) {
      return $great$great$eq((function (param) {
                    return $unknown$great((function (param) {
                                  return $unknown$great((function (param) {
                                                return pChar((function (param) {
                                                              return Caml_obj.caml_equal("(", param);
                                                            }), param);
                                              }), p, param);
                                }), (function (param) {
                                  return pChar((function (param) {
                                                return Caml_obj.caml_equal(")", param);
                                              }), param);
                                }), param);
                  }), (function (param) {
                    return /* Paren */Block.__(5, [param[0][1]]);
                  }), param);
    });
}

function valueParser(p) {
  var partial_arg = parenParser(p);
  return (function (param) {
      return $unknown$pipe(numberParser, partial_arg, param);
    });
}

function opParser(opType) {
  return (function (param) {
      return $great$great$eq((function (param) {
                    return pChar((function (c) {
                                  if (opType) {
                                    if (c === "*") {
                                      return true;
                                    } else {
                                      return c === "/";
                                    }
                                  } else if (c === "+") {
                                    return true;
                                  } else {
                                    return c === "-";
                                  }
                                }), param);
                  }), (function (c, n1, n2) {
                    switch (c) {
                      case "*" : 
                          return /* Multiply */Block.__(3, [
                                    n1,
                                    n2
                                  ]);
                      case "+" : 
                          return /* Add */Block.__(1, [
                                    n1,
                                    n2
                                  ]);
                      case "-" : 
                          return /* Minus */Block.__(2, [
                                    n1,
                                    n2
                                  ]);
                      case "/" : 
                          return /* Divid */Block.__(4, [
                                    n1,
                                    n2
                                  ]);
                      default:
                        throw [
                              ParseError,
                              "op parser error"
                            ];
                    }
                  }), param);
    });
}

function computeParser(opType, expressionParser) {
  var partial_arg = opParser(opType);
  var partial_arg$1 = function (param) {
    return $unknown$great(partial_arg, expressionParser, param);
  };
  var partial_arg$2 = function (param) {
    return many(partial_arg$1, param);
  };
  var partial_arg$3 = function (param) {
    return $unknown$great(expressionParser, partial_arg$2, param);
  };
  return (function (param) {
      return $great$great$eq(partial_arg$3, (function (param) {
                    return param[1].reduce((function (res, param) {
                                  return Curry._2(param[0], res, param[1]);
                                }), param[0]);
                  }), param);
    });
}

function genAddminusParser(param) {
  return computeParser(/* AddMinus */0, param);
}

function genMulDivParser(param) {
  return computeParser(/* MulDiv */1, param);
}

function makeParser(genParser, valueParser, parser) {
  var expressionParser = Curry._1(valueParser, parser);
  var partial_arg = Curry._1(genParser, expressionParser);
  return (function (param) {
      return $unknown$pipe(partial_arg, expressionParser, param);
    });
}

function parser_(input) {
  var mulDivParser = makeParser(genMulDivParser, valueParser, parser_);
  return makeParser(genAddminusParser, (function (p) {
                  var partial_arg = parenParser(p);
                  var partial_arg$1 = function (param) {
                    return $unknown$pipe(numberParser, partial_arg, param);
                  };
                  return (function (param) {
                      return $unknown$pipe(mulDivParser, partial_arg$1, param);
                    });
                }), parser_)(input);
}

function parser(param) {
  return $great$great$eq((function (param) {
                return $unknown$great(parser_, empty, param);
              }), (function (param) {
                return param[0];
              }), param);
}

var exp = "5*(1+1)";

var match = parser(exp);

if (match.tag) {
  console.log(match[0]);
} else {
  console.log(ExpressionEvaluator$ExpressionParser.$$eval(match[0][0]));
}

exports.ParseError = ParseError;
exports.run = run;
exports.pChar = pChar;
exports.$pipe$at$ = $pipe$at$;
exports.$pipe$at$caret = $pipe$at$caret;
exports.$unknown$great = $unknown$great;
exports.$unknown$pipe = $unknown$pipe;
exports.$great$great$eq = $great$great$eq;
exports.isChar = isChar;
exports.isNumberChar = isNumberChar;
exports.many = many;
exports.empty = empty;
exports.numberParser = numberParser;
exports.parenParser = parenParser;
exports.valueParser = valueParser;
exports.opParser = opParser;
exports.computeParser = computeParser;
exports.genAddminusParser = genAddminusParser;
exports.genMulDivParser = genMulDivParser;
exports.makeParser = makeParser;
exports.parser_ = parser_;
exports.parser = parser;
exports.exp = exp;
/* match Not a pure module */
